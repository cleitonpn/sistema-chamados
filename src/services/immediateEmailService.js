/**
 * Servi√ßo de E-mail Imediato
 * Solu√ß√£o que funciona diretamente do frontend sem problemas de CORS
 */

class ImmediateEmailService {
  constructor() {
    this.isEnabled = true;
    this.emailQueue = [];
    this.templates = this.initializeTemplates();
    
    // Configura√ß√£o EmailJS (servi√ßo gratuito que funciona do frontend)
    this.emailJSConfig = {
      serviceId: 'service_uset_notifications',
      templateId: 'template_ticket_notification',
      publicKey: 'user_uset_notifications'
    };
    
    // Fallback: usar mailto para casos cr√≠ticos
    this.useMailtoFallback = true;
    
    console.log('üìß Servi√ßo de e-mail imediato inicializado');
  }

  // Inicializar templates de e-mail
  initializeTemplates() {
    return {
      new_ticket: {
        subject: 'üé´ Novo Chamado Criado - #{ticketId}',
        template: `
          Novo Chamado Criado
          
          #{ticketId} - {titulo}
          
          √Årea: {area}
          Prioridade: {prioridade}
          Criado por: {criadoPorNome}
          Data: {dataFormatada}
          
          Descri√ß√£o:
          {descricao}
          
          Acesse o sistema: {systemUrl}
        `
      },
      
      ticket_updated: {
        subject: 'üîÑ Chamado Atualizado - #{ticketId}',
        template: `
          Chamado Atualizado
          
          #{ticketId} - {titulo}
          
          Status: {status}
          √Årea: {area}
          Atualizado por: {atualizadoPorNome}
          Data: {dataFormatada}
          
          {ultimaAtualizacao && '√öltima atualiza√ß√£o: ' + ultimaAtualizacao}
          
          Acesse o sistema: {systemUrl}
        `
      },
      
      ticket_escalated: {
        subject: '‚ö†Ô∏è Chamado Escalado - #{ticketId}',
        template: `
          Chamado Escalado
          
          #{ticketId} - {titulo}
          
          Escalado para: {escaladoPara}
          √Årea: {area}
          Prioridade: {prioridade}
          Escalado por: {escaladoPorNome}
          Data: {dataFormatada}
          
          {motivo && 'Motivo da Escala√ß√£o: ' + motivo}
          
          Acesse o sistema: {systemUrl}
        `
      },
      
      ticket_completed: {
        subject: '‚úÖ Chamado Conclu√≠do - #{ticketId}',
        template: `
          Chamado Conclu√≠do
          
          #{ticketId} - {titulo}
          
          Status: Conclu√≠do
          √Årea: {area}
          Conclu√≠do por: {concluidoPorNome}
          Data: {dataFormatada}
          
          {resolucao && 'Resolu√ß√£o: ' + resolucao}
          
          Acesse o sistema: {systemUrl}
        `
      }
    };
  }

  // Enviar notifica√ß√£o por e-mail (m√©todo principal)
  async sendNotification(ticket, eventType, currentUser, allUsers = []) {
    if (!this.isEnabled) {
      console.log('üìß Servi√ßo de e-mail desabilitado');
      return;
    }

    try {
      console.log(`üìß Enviando notifica√ß√£o de ${eventType} para chamado ${ticket.id}`);
      
      // Obter destinat√°rios baseado no tipo de evento e usu√°rios reais
      const recipients = await this.getRecipientsForEvent(eventType, ticket, currentUser, allUsers);
      
      if (recipients.length === 0) {
        console.log('üìß Nenhum destinat√°rio encontrado para notifica√ß√£o');
        return;
      }

      // Preparar dados do e-mail
      const emailData = this.prepareEmailData(ticket, eventType, currentUser);
      
      // Tentar enviar via SendGrid
      const success = await this.sendViaMultipleMethods(recipients, emailData, eventType);
      
      if (success) {
        console.log(`‚úÖ Notifica√ß√£o enviada com sucesso para ${recipients.length} destinat√°rio(s)`);
      } else {
        console.warn('‚ö†Ô∏è Falha ao enviar notifica√ß√£o por e-mail');
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar notifica√ß√£o:', error);
    }
  }

  // Obter destinat√°rios baseado no evento
  async getRecipientsForEvent(eventType, ticket, currentUser, allUsers) {
    const recipients = [];
    
    try {
      console.log(`üìß Obtendo destinat√°rios para evento: ${eventType}`);
      console.log(`üìß Usu√°rios dispon√≠veis: ${allUsers?.length || 0}`);
      
      // Baseado no tipo de evento e regras de neg√≥cio
      switch (eventType) {
        case 'new_ticket':
          // 1. Notificar operadores da √°rea espec√≠fica do chamado
          if (ticket.area) {
            const operadoresArea = allUsers?.filter(user => 
              user.funcao === 'operador' && 
              user.area === ticket.area &&
              user.email
            ) || [];
            
            operadoresArea.forEach(operador => {
              recipients.push(operador.email);
              console.log(`üìß Adicionado operador da √°rea ${ticket.area}: ${operador.email}`);
            });
          }
          
          // 2. Notificar apenas o produtor respons√°vel pelo projeto (n√£o todos)
          if (ticket.projetoId) {
            // Buscar o projeto para encontrar o produtor respons√°vel
            try {
              const { projectService } = await import('../services/projectService');
              const projeto = await projectService.getProjectById(ticket.projetoId);
              
              if (projeto?.produtorResponsavel) {
                const produtorResponsavel = allUsers?.find(user => 
                  user.uid === projeto.produtorResponsavel && user.email
                );
                
                if (produtorResponsavel) {
                  recipients.push(produtorResponsavel.email);
                  console.log(`üìß Adicionado produtor respons√°vel pelo projeto: ${produtorResponsavel.email}`);
                }
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Erro ao buscar produtor respons√°vel:', error);
              // Fallback: notificar criador se for produtor
              if (ticket.criadoPorFuncao === 'produtor') {
                const criadorProdutor = allUsers?.find(user => user.uid === ticket.criadoPor);
                if (criadorProdutor?.email) {
                  recipients.push(criadorProdutor.email);
                  console.log(`üìß Adicionado criador produtor: ${criadorProdutor.email}`);
                }
              }
            }
          }
          
          break;
          
        case 'ticket_updated':
          // 1. Notificar o criador do chamado (se n√£o for o usu√°rio atual)
          if (ticket.criadoPor && ticket.criadoPor !== currentUser?.uid) {
            const criador = allUsers?.find(user => user.uid === ticket.criadoPor);
            if (criador?.email) {
              recipients.push(criador.email);
              console.log(`üìß Adicionado criador do chamado: ${criador.email}`);
            }
          }
          
          // 2. Notificar operadores da √°rea
          if (ticket.area) {
            const operadoresArea = allUsers?.filter(user => 
              user.funcao === 'operador' && 
              user.area === ticket.area &&
              user.email &&
              user.uid !== currentUser?.uid
            ) || [];
            
            operadoresArea.forEach(operador => {
              recipients.push(operador.email);
              console.log(`üìß Adicionado operador da √°rea: ${operador.email}`);
            });
          }
          
          break;
          
        case 'ticket_escalated':
          // Se escalado para ger√™ncia, notificar gerente espec√≠fico da √°rea
          if (ticket.escaladoPara === 'gerencia') {
            // Mapeamento de √°reas para gerentes espec√≠ficos
            const mapeamentoGerentes = {
              'compras': 'gerente_operacional',
              'locacao': 'gerente_operacional', 
              'operacao': 'gerente_operacional',
              'logistica': 'gerente_operacional',
              'comercial': 'gerente_comercial',
              'produtor': 'gerente_producao',
              'almoxarifado': 'gerente_producao',
              'financeiro': 'gerente_financeiro'
            };
            
            const tipoGerente = mapeamentoGerentes[ticket.area?.toLowerCase()];
            if (tipoGerente) {
              const gerenteEspecifico = allUsers?.find(user => 
                user.funcao === 'gerente' && 
                user.area === tipoGerente &&
                user.email
              );
              
              if (gerenteEspecifico) {
                recipients.push(gerenteEspecifico.email);
                console.log(`üìß Adicionado gerente espec√≠fico da √°rea ${ticket.area}: ${gerenteEspecifico.email}`);
              }
            }
          }
          
          // Se escalado para √°rea espec√≠fica, notificar operadores dessa √°rea
          else if (ticket.escaladoPara && ticket.escaladoPara !== 'gerencia') {
            const operadoresEscalados = allUsers?.filter(user => 
              user.funcao === 'operador' && 
              user.area === ticket.escaladoPara &&
              user.email
            ) || [];
            
            operadoresEscalados.forEach(operador => {
              recipients.push(operador.email);
              console.log(`üìß Adicionado operador da √°rea escalada ${ticket.escaladoPara}: ${operador.email}`);
            });
          }
          
          break;
          
        case 'ticket_completed':
          // 1. Notificar o criador do chamado
          if (ticket.criadoPor) {
            const criador = allUsers?.find(user => user.uid === ticket.criadoPor);
            if (criador?.email) {
              recipients.push(criador.email);
              console.log(`üìß Adicionado criador para conclus√£o: ${criador.email}`);
            }
          }
          
          // 2. Notificar apenas o produtor respons√°vel pelo projeto (para valida√ß√£o)
          if (ticket.projetoId) {
            try {
              const { projectService } = await import('../services/projectService');
              const projeto = await projectService.getProjectById(ticket.projetoId);
              
              if (projeto?.produtorResponsavel) {
                const produtorResponsavel = allUsers?.find(user => 
                  user.uid === projeto.produtorResponsavel && user.email
                );
                
                if (produtorResponsavel) {
                  recipients.push(produtorResponsavel.email);
                  console.log(`üìß Adicionado produtor respons√°vel para valida√ß√£o: ${produtorResponsavel.email}`);
                }
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Erro ao buscar produtor respons√°vel para valida√ß√£o:', error);
            }
          }
          
          break;
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao obter destinat√°rios:', error);
    }
    
    // Remover duplicatas e e-mails inv√°lidos
    const uniqueRecipients = [...new Set(recipients)].filter(email => 
      email && 
      email.includes('@') && 
      email.includes('.') &&
      email !== 'sistemauset@gmail.com' // Remover remetente dos destinat√°rios
    );
    
    console.log(`üìß Destinat√°rios finais (${uniqueRecipients.length}):`, uniqueRecipients);
    return uniqueRecipients;
  }

  // Preparar dados do e-mail
  prepareEmailData(ticket, eventType, currentUser) {
    const template = this.templates[eventType];
    if (!template) {
      throw new Error(`Template n√£o encontrado para evento: ${eventType}`);
    }

    // Dados base
    const baseData = {
      ticketId: ticket.id || 'N/A',
      titulo: ticket.titulo || 'Sem t√≠tulo',
      area: ticket.area || 'N√£o definida',
      prioridade: ticket.prioridade || 'Normal',
      status: ticket.status || 'Aberto',
      descricao: ticket.descricao || 'Sem descri√ß√£o',
      dataFormatada: new Date().toLocaleString('pt-BR'),
      systemUrl: window.location.origin,
      criadoPorNome: currentUser?.nome || 'Sistema',
      atualizadoPorNome: currentUser?.nome || 'Sistema',
      escaladoPorNome: currentUser?.nome || 'Sistema',
      concluidoPorNome: currentUser?.nome || 'Sistema'
    };

    // Processar template
    let subject = template.subject;
    let body = template.template;

    // Substituir vari√°veis no subject e body
    Object.keys(baseData).forEach(key => {
      const value = baseData[key] || '';
      subject = subject.replace(new RegExp(`{${key}}`, 'g'), value);
      body = body.replace(new RegExp(`{${key}}`, 'g'), value);
    });

    return {
      subject,
      body,
      data: baseData
    };
  }

  // Enviar via m√∫ltiplos m√©todos (fallback)
  async sendViaMultipleMethods(recipients, emailData, eventType = 'new_ticket') {
    // M√©todo 1: Tentar via SendGrid backend
    try {
      const success = await this.sendViaSimpleFetch(recipients, emailData, eventType);
      if (success) {
        console.log('‚úÖ E-mail enviado automaticamente via SendGrid');
        return true;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Envio autom√°tico SendGrid falhou:', error.message);
    }

    // Se falhar, salvar na fila para tentar novamente depois
    console.log('üìù Salvando na fila para nova tentativa autom√°tica');
    this.addToQueue(recipients, emailData, eventType);
    return false; // N√£o abrir cliente de e-mail
  }

  // M√©todo 1: SendGrid via backend (m√©todo principal)
  async sendViaSimpleFetch(recipients, emailData, eventType = 'new_ticket') {
    try {
      // Usar o backend SendGrid permanente
      const response = await fetch('https://lnh8imcd1j93.manus.space/api/email/send-notification', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          eventType: eventType,
          ticket: {
            id: emailData.data.ticketId,
            numero: emailData.data.ticketId,
            titulo: emailData.data.titulo,
            descricao: emailData.data.descricao,
            area: emailData.data.area,
            prioridade: emailData.data.prioridade,
            status: emailData.data.status,
            criadoPor: 'sistema',
            createdAt: new Date().toISOString()
          },
          recipients: recipients,
          currentUser: {
            uid: 'sistema',
            nome: emailData.data.criadoPorNome || 'Sistema',
            funcao: 'sistema'
          },
          allUsers: []
        })
      });

      if (response.ok) {
        const result = await response.json();
        console.log('‚úÖ E-mail enviado via SendGrid:', result);
        return true;
      } else {
        const error = await response.text();
        console.warn('‚ö†Ô∏è Erro na resposta SendGrid:', error);
        return false;
      }
    } catch (error) {
      console.error('‚ùå Erro ao enviar via SendGrid:', error);
      return false;
    }
  }

  // M√©todo 2: Mailto (abre cliente de e-mail do usu√°rio)
  sendViaMailto(recipients, emailData) {
    const mailtoUrl = `mailto:${recipients.join(',')}?subject=${encodeURIComponent(emailData.subject)}&body=${encodeURIComponent(emailData.body)}`;
    
    // Abrir em nova janela para n√£o interromper o fluxo
    window.open(mailtoUrl, '_blank');
    
    console.log('üìß E-mail aberto no cliente padr√£o do usu√°rio');
  }

  // M√©todo 3: Adicionar √† fila para envio posterior
  addToQueue(recipients, emailData, eventType = 'new_ticket') {
    const queueItem = {
      id: Date.now(),
      recipients,
      emailData,
      eventType,
      timestamp: new Date().toISOString(),
      attempts: 0
    };
    
    this.emailQueue.push(queueItem);
    
    // Salvar na localStorage para persist√™ncia
    try {
      localStorage.setItem('emailQueue', JSON.stringify(this.emailQueue));
      console.log('üìß E-mail adicionado √† fila para envio posterior');
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao salvar fila de e-mails:', error);
    }
  }

  // Processar fila de e-mails
  async processQueue() {
    if (this.emailQueue.length === 0) return;

    console.log(`üìß Processando ${this.emailQueue.length} e-mails na fila`);

    for (let i = this.emailQueue.length - 1; i >= 0; i--) {
      const item = this.emailQueue[i];
      
      try {
        const success = await this.sendViaSimpleFetch(item.recipients, item.emailData, item.eventType || 'new_ticket');
        
        if (success) {
          this.emailQueue.splice(i, 1);
          console.log(`‚úÖ E-mail da fila enviado: ${item.emailData.subject}`);
        } else {
          item.attempts++;
          if (item.attempts >= 3) {
            this.emailQueue.splice(i, 1);
            console.warn(`‚ùå E-mail removido da fila ap√≥s 3 tentativas: ${item.emailData.subject}`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Erro ao processar item da fila:`, error);
      }
    }

    // Atualizar localStorage
    try {
      localStorage.setItem('emailQueue', JSON.stringify(this.emailQueue));
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao atualizar fila de e-mails:', error);
    }
  }

  // Carregar fila do localStorage
  loadQueue() {
    try {
      const saved = localStorage.getItem('emailQueue');
      if (saved) {
        this.emailQueue = JSON.parse(saved);
        console.log(`üìß Carregados ${this.emailQueue.length} e-mails da fila`);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao carregar fila de e-mails:', error);
      this.emailQueue = [];
    }
  }

  // Habilitar/desabilitar servi√ßo
  setEnabled(enabled) {
    this.isEnabled = enabled;
    console.log(`üìß Servi√ßo de e-mail ${enabled ? 'habilitado' : 'desabilitado'}`);
  }

  // Obter status do servi√ßo
  getStatus() {
    return {
      enabled: this.isEnabled,
      queueSize: this.emailQueue.length,
      lastProcessed: new Date().toISOString()
    };
  }
}

// Inst√¢ncia global
export const immediateEmailService = new ImmediateEmailService();

// Carregar fila ao inicializar
immediateEmailService.loadQueue();

// Processar fila a cada 30 segundos
setInterval(() => {
  immediateEmailService.processQueue();
}, 30000);

export default immediateEmailService;

